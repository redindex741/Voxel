<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, user-scalable=no"
  />
  <title>Adaptive Voxel Editor</title>
  <style>
    :root {
      --video-w: 320px;
      --video-h: 240px;
      --info-right: 20px;
      --control-bottom: 20px;
    }
    body.mobile {
      --video-w: 220px;
      --video-h: 165px;
      --info-right: 10px;
      --control-bottom: 10px;
      touch-action: none;
    }
    body {
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        Arial, sans-serif;
      background: #000;
      color: #fff;
    }
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    #video {
      position: absolute;
      top: 20px;
      left: 20px;
      width: var(--video-w);
      height: var(--video-h);
      z-index: 100;
      border: 2px solid #00ff00;
      border-radius: 12px;
      object-fit: cover;
    }
    #output_canvas {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 99;
      border-radius: 12px;
    }
    #info {
      position: absolute;
      top: 20px;
      right: var(--info-right);
      background: rgba(0, 0, 0, 0.85);
      padding: 12px 14px;
      border-radius: 12px;
      min-width: 230px;
      font-size: 13px;
    }
    #controls {
      position: absolute;
      bottom: var(--control-bottom);
      left: 20px;
      background: rgba(0, 0, 0, 0.85);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 13px;
    }
    button {
      background: #44ff44;
      color: #000;
      border: none;
      padding: 6px 12px;
      margin: 2px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
    }
    button:hover,
    button:active {
      background: #00ff00;
    }
    #stats {
      margin-top: 6px;
      font-size: 11px;
      color: #aaa;
    }
    .mobile-only {
      display: none;
    }
    body.mobile .mobile-only {
      display: block;
    }
  </style>
</head>
<body>
  <div id="container">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="output_canvas" width="320" height="240"></canvas>

    <div id="info">
      <div><strong>üéÆ Adaptive Voxel Editor</strong></div>
      <div id="device-info" class="mobile-only">üì± Mobile mode</div>
      <div>üëÜ Index finger: Aim</div>
      <div>‚úåÔ∏è Pinch: Add / Remove voxel</div>
      <div>üñ±Ô∏è Mouse drag: Orbit (PC)</div>
      <div class="mobile-only">üñêÔ∏è 2‚Äëfinger drag: Rotate (Phone)</div>
      <div id="status">Initializing‚Ä¶</div>
      <div id="stats">Voxels: 0 | FPS: --</div>
    </div>

    <div id="controls">
      <button id="clearBtn">üóëÔ∏è Clear</button>
      <button id="gridBtn">üìê Grid</button>
      <button id="exportBtn">üíæ Export OBJ</button>
      <div style="margin-top: 6px">
        Size:
        <input
          type="range"
          id="sizeSlider"
          min="0.5"
          max="2"
          step="0.1"
          value="1"
        />
      </div>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.169.0/examples/js/controls/OrbitControls.js"></script>

  <!-- MediaPipe (Hands + drawing only) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js"></script>

  <script>
    // --- DEVICE DETECT ---
    const isMobile =
      /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ||
      window.innerWidth <= 768;
    if (isMobile) document.body.classList.add("mobile");

    // --- THREE.JS SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    const renderer = new THREE.WebGLRenderer({ antialias: !isMobile });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById("container").appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    camera.position.set(isMobile ? 6 : 8, isMobile ? 6 : 8, isMobile ? 6 : 8);
    controls.enableDamping = true;

    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(10, 15, 8);
    scene.add(ambient);
    scene.add(dir);

    const GRID_SIZE = isMobile ? 24 : 32;
    const gridHelper = new THREE.GridHelper(
      GRID_SIZE,
      GRID_SIZE / 2,
      0x444444,
      0x222222
    );
    scene.add(gridHelper);

    const voxelData = new Map();
    const voxelMeshes = [];
    let voxelSize = 1;
    let fps = 0;
    let lastTime = performance.now();
    let frameCount = 0;

    function createVoxel(x, y, z) {
      const geo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
      const mat = new THREE.MeshLambertMaterial({
        color: new THREE.Color().setHSL(
          0.3 + Math.random() * 0.1,
          0.8,
          0.6
        ),
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, y, z);
      scene.add(mesh);
      voxelMeshes.push(mesh);
      return mesh;
    }

    function toggleVoxel(worldPos) {
      const gx = Math.floor(worldPos.x + GRID_SIZE / 2);
      const gy = Math.floor(worldPos.y);
      const gz = Math.floor(worldPos.z + GRID_SIZE / 2);
      const key = `${gx}_${gy}_${gz}`;

      if (voxelData.has(key)) {
        const mesh = voxelData.get(key);
        scene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
        voxelMeshes.splice(voxelMeshes.indexOf(mesh), 1);
        voxelData.delete(key);
      } else {
        const mesh = createVoxel(
          gx - GRID_SIZE / 2,
          gy,
          gz - GRID_SIZE / 2
        );
        voxelData.set(key, mesh);
      }
      updateStats();
    }

    // --- MEDIAPIPE HANDS with direct getUserMedia ---
    const videoElement = document.getElementById("video");
    const canvasElement = document.getElementById("output_canvas");
    const canvasCtx = canvasElement.getContext("2d");
    if (isMobile) {
      canvasElement.width = 220;
      canvasElement.height = 165;
    }

    let handPos = new THREE.Vector3();
    let isPinch = false;
    let pinchCooldown = 0;
    const raycaster = new THREE.Raycaster();

    function updateStatus(msg) {
      document.getElementById("status").textContent = msg;
    }

    function updateStats() {
      document.getElementById(
        "stats"
      ).textContent = `Voxels: ${voxelData.size} | FPS: ${fps.toFixed(0)}`;
    }

    const hands = new Hands({
      locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`,
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: isMobile ? 0 : 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.6,
    });
    hands.onResults(onResults);

    async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: isMobile ? "user" : "environment" },
      audio: false,
    });
    videoElement.srcObject = stream;
    updateStatus("‚úÖ Camera started ‚Äì show your hand");
    videoElement.onloadedmetadata = () => {
      videoElement.play();
      processVideoFrame();
    };
  } catch (e) {
    console.error("getUserMedia error:", e.name, e.message);   // NEW
    updateStatus("‚ùå Camera error: " + e.name + " ‚Äì " + e.message); // NEW
  }
    }

    async function processVideoFrame() {
      if (videoElement.readyState === 4) {
        await hands.send({ image: videoElement });
      }
      requestAnimationFrame(processVideoFrame);
    }

    function onResults(results) {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      if (videoElement.readyState === 4) {
        canvasCtx.drawImage(
          videoElement,
          0,
          0,
          canvasElement.width,
          canvasElement.height
        );
      }

      if (results.multiHandLandmarks && results.multiHandLandmarks[0]) {
        const landmarks = results.multiHandLandmarks[0];
        window.drawConnectors(canvasCtx, landmarks, Hands.HAND_CONNECTIONS, {
          color: "#00FF00",
          lineWidth: 2,
        });
        window.drawLandmarks(canvasCtx, landmarks, {
          color: "#FF4444",
          lineWidth: 1,
        });

        const indexTip = landmarks[8];
        const thumbTip = landmarks[4];

        const dist = Math.hypot(
          (indexTip.x - thumbTip.x) * canvasElement.width,
          (indexTip.y - thumbTip.y) * canvasElement.height
        );
        isPinch = dist < (isMobile ? 40 : 55);

        const depth = 4 + indexTip.z * 3;
        handPos.set(
          (indexTip.x - 0.5) * (isMobile ? 8 : 12),
          -(indexTip.y - 0.5) * (isMobile ? 8 : 12),
          depth
        );
        updateStatus(
          `Hand OK ‚Ä¢ Pinch: ${isPinch ? "ON" : "OFF"}`
        );
      } else {
        isPinch = false;
        updateStatus("Show your hand to the camera");
      }

      canvasCtx.restore();
    }

    function handleHandInteraction() {
      if (!isPinch || handPos.length() === 0) return;
      if (pinchCooldown > 0) {
        pinchCooldown--;
        return;
      }

      const dirVec = handPos.clone().sub(camera.position).normalize();
      raycaster.set(camera.position, dirVec);
      const intersects = raycaster.intersectObjects(voxelMeshes);
      const point =
        intersects.length > 0
          ? intersects[0].point
          : camera.position.clone().add(dirVec.multiplyScalar(5));

      toggleVoxel(point);
      pinchCooldown = isMobile ? 10 : 6;
    }

    // --- UI BUTTONS ---
    document.getElementById("clearBtn").onclick = () => {
      voxelMeshes.forEach((m) => {
        scene.remove(m);
        m.geometry.dispose();
        m.material.dispose();
      });
      voxelMeshes.length = 0;
      voxelData.clear();
      updateStats();
    };
    document.getElementById("gridBtn").onclick = () => {
      gridHelper.visible = !gridHelper.visible;
    };
    document.getElementById("exportBtn").onclick = () => {
      let obj = "# voxel export
";
      voxelData.forEach((mesh) => {
        const p = mesh.position;
        obj += `v ${p.x} ${p.y} ${p.z}
`;
      });
      const blob = new Blob([obj], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "voxels.obj";
      a.click();
    };
    document.getElementById("sizeSlider").oninput = (e) => {
      voxelSize = parseFloat(e.target.value);
      voxelMeshes.forEach((m) => m.scale.setScalar(voxelSize));
    };

    // --- ANIMATION LOOP ---
    function animate() {
      requestAnimationFrame(animate);
      frameCount++;
      if (frameCount % 30 === 0) {
        const now = performance.now();
        fps = (30 * 1000) / (now - lastTime);
        lastTime = now;
        updateStats();
      }
      handleHandInteraction();
      controls.update();
      renderer.render(scene, camera);
    }

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // START
    startCamera();  // same style as working WebRTC sample[web:44][web:67]
    animate();
  </script>
</body>
</html>
